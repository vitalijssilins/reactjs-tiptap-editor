import { jsxs as it, jsx as T } from "react/jsx-runtime";
import { useState as Gt, useEffect as He } from "react";
import { M as Me, c as De, m as _t, P as Pt, a as te, x as Ue, y as je, z as Be, B as ze, C as Fe, F as We, T as Ke } from "./index-sel2RZJw.js";
import { A as Ge } from "./ActionButton-D15ZSL0z.js";
import { u as _e } from "./index-ZqXobaiP.js";
import { L as Ut } from "./label-BUeBtRLx.js";
import { I as fe } from "./input-BQQ_iBrZ.js";
import { S as Qe } from "./switch-0YJM0dmn.js";
import { I as Te } from "./Icon-BXO4CVnL.js";
import { B as $e } from "./button-CcHmDfB3.js";
import { P as qe, a as Je, b as Ve } from "./popover-B8VvcibZ.js";
const Ye = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", Xe = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", z = (t, n) => {
  for (const e in n)
    t[e] = n[e];
  return t;
}, Qt = "numeric", $t = "ascii", qt = "alpha", _ = "asciinumeric", G = "alphanumeric", Jt = "domain", xe = "emoji", Ze = "scheme", tn = "slashscheme", jt = "whitespace";
function en(t, n) {
  return t in n || (n[t] = []), n[t];
}
function U(t, n, e) {
  n[Qt] && (n[_] = !0, n[G] = !0), n[$t] && (n[_] = !0, n[qt] = !0), n[_] && (n[G] = !0), n[qt] && (n[G] = !0), n[G] && (n[Jt] = !0), n[xe] && (n[Jt] = !0);
  for (const i in n) {
    const o = en(i, e);
    o.indexOf(t) < 0 && o.push(t);
  }
}
function nn(t, n) {
  const e = {};
  for (const i in n)
    n[i].indexOf(t) >= 0 && (e[i] = !0);
  return e;
}
function y(t = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
y.groups = {};
y.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const n = this, e = n.j[t];
    if (e)
      return e;
    for (let i = 0; i < n.jr.length; i++) {
      const o = n.jr[i][0], s = n.jr[i][1];
      if (s && o.test(t))
        return s;
    }
    return n.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, n = !1) {
    return n ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, n, e, i) {
    for (let o = 0; o < t.length; o++)
      this.tt(t[o], n, e, i);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, n, e, i) {
    i = i || y.groups;
    let o;
    return n && n.j ? o = n : (o = new y(n), e && i && U(n, e, i)), this.jr.push([t, o]), o;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, n, e, i) {
    let o = this;
    const s = t.length;
    if (!s)
      return o;
    for (let r = 0; r < s - 1; r++)
      o = o.tt(t[r]);
    return o.tt(t[s - 1], n, e, i);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, n, e, i) {
    i = i || y.groups;
    const o = this;
    if (n && n.j)
      return o.j[t] = n, n;
    const s = n;
    let r, l = o.go(t);
    if (l ? (r = new y(), z(r.j, l.j), r.jr.push.apply(r.jr, l.jr), r.jd = l.jd, r.t = l.t) : r = new y(), s) {
      if (i)
        if (r.t && typeof r.t == "string") {
          const h = z(nn(r.t, i), e);
          U(s, h, i);
        } else e && U(s, e, i);
      r.t = s;
    }
    return o.j[t] = r, r;
  }
};
const d = (t, n, e, i, o) => t.ta(n, e, i, o), k = (t, n, e, i, o) => t.tr(n, e, i, o), me = (t, n, e, i, o) => t.ts(n, e, i, o), a = (t, n, e, i, o) => t.tt(n, e, i, o), w = "WORD", Vt = "UWORD", Ce = "ASCIINUMERICAL", be = "ALPHANUMERICAL", Y = "LOCALHOST", Yt = "TLD", Xt = "UTLD", ot = "SCHEME", B = "SLASH_SCHEME", ee = "NUM", Zt = "WS", ne = "NL", Q = "OPENBRACE", $ = "CLOSEBRACE", st = "OPENBRACKET", rt = "CLOSEBRACKET", at = "OPENPAREN", lt = "CLOSEPAREN", ct = "OPENANGLEBRACKET", ut = "CLOSEANGLEBRACKET", dt = "FULLWIDTHLEFTPAREN", ht = "FULLWIDTHRIGHTPAREN", ft = "LEFTCORNERBRACKET", mt = "RIGHTCORNERBRACKET", gt = "LEFTWHITECORNERBRACKET", pt = "RIGHTWHITECORNERBRACKET", Et = "FULLWIDTHLESSTHAN", kt = "FULLWIDTHGREATERTHAN", At = "AMPERSAND", ie = "APOSTROPHE", Lt = "ASTERISK", H = "AT", Tt = "BACKSLASH", xt = "BACKTICK", Ct = "CARET", M = "COLON", oe = "COMMA", bt = "DOLLAR", O = "DOT", yt = "EQUALS", se = "EXCLAMATION", S = "HYPHEN", q = "PERCENT", Rt = "PIPE", St = "PLUS", Ot = "POUND", J = "QUERY", re = "QUOTE", ye = "FULLWIDTHMIDDLEDOT", ae = "SEMI", v = "SLASH", V = "TILDE", vt = "UNDERSCORE", Re = "EMOJI", Nt = "SYM";
var Se = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD: w,
  UWORD: Vt,
  ASCIINUMERICAL: Ce,
  ALPHANUMERICAL: be,
  LOCALHOST: Y,
  TLD: Yt,
  UTLD: Xt,
  SCHEME: ot,
  SLASH_SCHEME: B,
  NUM: ee,
  WS: Zt,
  NL: ne,
  OPENBRACE: Q,
  CLOSEBRACE: $,
  OPENBRACKET: st,
  CLOSEBRACKET: rt,
  OPENPAREN: at,
  CLOSEPAREN: lt,
  OPENANGLEBRACKET: ct,
  CLOSEANGLEBRACKET: ut,
  FULLWIDTHLEFTPAREN: dt,
  FULLWIDTHRIGHTPAREN: ht,
  LEFTCORNERBRACKET: ft,
  RIGHTCORNERBRACKET: mt,
  LEFTWHITECORNERBRACKET: gt,
  RIGHTWHITECORNERBRACKET: pt,
  FULLWIDTHLESSTHAN: Et,
  FULLWIDTHGREATERTHAN: kt,
  AMPERSAND: At,
  APOSTROPHE: ie,
  ASTERISK: Lt,
  AT: H,
  BACKSLASH: Tt,
  BACKTICK: xt,
  CARET: Ct,
  COLON: M,
  COMMA: oe,
  DOLLAR: bt,
  DOT: O,
  EQUALS: yt,
  EXCLAMATION: se,
  HYPHEN: S,
  PERCENT: q,
  PIPE: Rt,
  PLUS: St,
  POUND: Ot,
  QUERY: J,
  QUOTE: re,
  FULLWIDTHMIDDLEDOT: ye,
  SEMI: ae,
  SLASH: v,
  TILDE: V,
  UNDERSCORE: vt,
  EMOJI: Re,
  SYM: Nt
});
const N = /[a-z]/, K = new RegExp("\\p{L}", "u"), Bt = new RegExp("\\p{Emoji}", "u"), P = /\d/, zt = /\s/, ge = "\r", Ft = `
`, on = "️", sn = "‍", Wt = "￼";
let tt = null, et = null;
function rn(t = []) {
  const n = {};
  y.groups = n;
  const e = new y();
  tt == null && (tt = pe(Ye)), et == null && (et = pe(Xe)), a(e, "'", ie), a(e, "{", Q), a(e, "}", $), a(e, "[", st), a(e, "]", rt), a(e, "(", at), a(e, ")", lt), a(e, "<", ct), a(e, ">", ut), a(e, "（", dt), a(e, "）", ht), a(e, "「", ft), a(e, "」", mt), a(e, "『", gt), a(e, "』", pt), a(e, "＜", Et), a(e, "＞", kt), a(e, "&", At), a(e, "*", Lt), a(e, "@", H), a(e, "`", xt), a(e, "^", Ct), a(e, ":", M), a(e, ",", oe), a(e, "$", bt), a(e, ".", O), a(e, "=", yt), a(e, "!", se), a(e, "-", S), a(e, "%", q), a(e, "|", Rt), a(e, "+", St), a(e, "#", Ot), a(e, "?", J), a(e, '"', re), a(e, "/", v), a(e, ";", ae), a(e, "~", V), a(e, "_", vt), a(e, "\\", Tt), a(e, "・", ye);
  const i = k(e, P, ee, {
    [Qt]: !0
  });
  k(i, P, i);
  const o = k(i, N, Ce, {
    [_]: !0
  }), s = k(i, K, be, {
    [G]: !0
  }), r = k(e, N, w, {
    [$t]: !0
  });
  k(r, P, o), k(r, N, r), k(o, P, o), k(o, N, o);
  const l = k(e, K, Vt, {
    [qt]: !0
  });
  k(l, N), k(l, P, s), k(l, K, l), k(s, P, s), k(s, N), k(s, K, s);
  const h = a(e, Ft, ne, {
    [jt]: !0
  }), c = a(e, ge, Zt, {
    [jt]: !0
  }), f = k(e, zt, Zt, {
    [jt]: !0
  });
  a(e, Wt, f), a(c, Ft, h), a(c, Wt, f), k(c, zt, f), a(f, ge), a(f, Ft), k(f, zt, f), a(f, Wt, f);
  const u = k(e, Bt, Re, {
    [xe]: !0
  });
  a(u, "#"), k(u, Bt, u), a(u, on, u);
  const g = a(u, sn);
  a(g, "#"), k(g, Bt, u);
  const p = [[N, r], [P, o]], b = [[N, null], [K, l], [P, s]];
  for (let A = 0; A < tt.length; A++)
    I(e, tt[A], Yt, w, p);
  for (let A = 0; A < et.length; A++)
    I(e, et[A], Xt, Vt, b);
  U(Yt, {
    tld: !0,
    ascii: !0
  }, n), U(Xt, {
    utld: !0,
    alpha: !0
  }, n), I(e, "file", ot, w, p), I(e, "mailto", ot, w, p), I(e, "http", B, w, p), I(e, "https", B, w, p), I(e, "ftp", B, w, p), I(e, "ftps", B, w, p), U(ot, {
    scheme: !0,
    ascii: !0
  }, n), U(B, {
    slashscheme: !0,
    ascii: !0
  }, n), t = t.sort((A, x) => A[0] > x[0] ? 1 : -1);
  for (let A = 0; A < t.length; A++) {
    const x = t[A][0], L = t[A][1] ? {
      [Ze]: !0
    } : {
      [tn]: !0
    };
    x.indexOf("-") >= 0 ? L[Jt] = !0 : N.test(x) ? P.test(x) ? L[_] = !0 : L[$t] = !0 : L[Qt] = !0, me(e, x, x, L);
  }
  return me(e, "localhost", Y, {
    ascii: !0
  }), e.jd = new y(Nt), {
    start: e,
    tokens: z({
      groups: n
    }, Se)
  };
}
function Oe(t, n) {
  const e = an(n.replace(/[A-Z]/g, (l) => l.toLowerCase())), i = e.length, o = [];
  let s = 0, r = 0;
  for (; r < i; ) {
    let l = t, h = null, c = 0, f = null, u = -1, g = -1;
    for (; r < i && (h = l.go(e[r])); )
      l = h, l.accepts() ? (u = 0, g = 0, f = l) : u >= 0 && (u += e[r].length, g++), c += e[r].length, s += e[r].length, r++;
    s -= u, r -= g, c -= u, o.push({
      t: f.t,
      // token type/name
      v: n.slice(s - c, s),
      // string value
      s: s - c,
      // start index
      e: s
      // end index (excluding)
    });
  }
  return o;
}
function an(t) {
  const n = [], e = t.length;
  let i = 0;
  for (; i < e; ) {
    let o = t.charCodeAt(i), s, r = o < 55296 || o > 56319 || i + 1 === e || (s = t.charCodeAt(i + 1)) < 56320 || s > 57343 ? t[i] : t.slice(i, i + 2);
    n.push(r), i += r.length;
  }
  return n;
}
function I(t, n, e, i, o) {
  let s;
  const r = n.length;
  for (let l = 0; l < r - 1; l++) {
    const h = n[l];
    t.j[h] ? s = t.j[h] : (s = new y(i), s.jr = o.slice(), t.j[h] = s), t = s;
  }
  return s = new y(e), s.jr = o.slice(), t.j[n[r - 1]] = s, s;
}
function pe(t) {
  const n = [], e = [];
  let i = 0, o = "0123456789";
  for (; i < t.length; ) {
    let s = 0;
    for (; o.indexOf(t[i + s]) >= 0; )
      s++;
    if (s > 0) {
      n.push(e.join(""));
      for (let r = parseInt(t.substring(i, i + s), 10); r > 0; r--)
        e.pop();
      i += s;
    } else
      e.push(t[i]), i++;
  }
  return n;
}
const X = {
  defaultProtocol: "http",
  events: null,
  format: Ee,
  formatHref: Ee,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function le(t, n = null) {
  let e = z({}, X);
  t && (e = z(e, t instanceof le ? t.o : t));
  const i = e.ignoreTags, o = [];
  for (let s = 0; s < i.length; s++)
    o.push(i[s].toUpperCase());
  this.o = e, n && (this.defaultRender = n), this.ignoreTags = o;
}
le.prototype = {
  o: X,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, n, e) {
    const i = n != null;
    let o = this.o[t];
    return o && (typeof o == "object" ? (o = e.t in o ? o[e.t] : X[t], typeof o == "function" && i && (o = o(n, e))) : typeof o == "function" && i && (o = o(n, e.t, e)), o);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, n, e) {
    let i = this.o[t];
    return typeof i == "function" && n != null && (i = i(n, e.t, e)), i;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const n = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(n, t.t, t);
  }
};
function Ee(t) {
  return t;
}
function ve(t, n) {
  this.t = "token", this.v = t, this.tk = n;
}
ve.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const n = this.toString(), e = t.get("truncate", n, this), i = t.get("format", n, this);
    return e && i.length > e ? i.substring(0, e) + "…" : i;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t = X.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const n = this, e = this.toHref(t.get("defaultProtocol")), i = t.get("formatHref", e, this), o = t.get("tagName", e, n), s = this.toFormattedString(t), r = {}, l = t.get("className", e, n), h = t.get("target", e, n), c = t.get("rel", e, n), f = t.getObj("attributes", e, n), u = t.getObj("events", e, n);
    return r.href = i, l && (r.class = l), h && (r.target = h), c && (r.rel = c), f && z(r, f), {
      tagName: o,
      attributes: r,
      content: s,
      eventListeners: u
    };
  }
};
function wt(t, n) {
  class e extends ve {
    constructor(o, s) {
      super(o, s), this.t = t;
    }
  }
  for (const i in n)
    e.prototype[i] = n[i];
  return e.t = t, e;
}
const ke = wt("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), Ae = wt("text"), ln = wt("nl"), nt = wt("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t = X.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== Y && t[1].t === M;
  }
}), R = (t) => new y(t);
function cn({
  groups: t
}) {
  const n = t.domain.concat([At, Lt, H, Tt, xt, Ct, bt, yt, S, ee, q, Rt, St, Ot, v, Nt, V, vt]), e = [M, oe, O, se, q, J, re, ae, ct, ut, Q, $, rt, st, at, lt, dt, ht, ft, mt, gt, pt, Et, kt], i = [At, ie, Lt, Tt, xt, Ct, bt, yt, S, Q, $, q, Rt, St, Ot, J, v, Nt, V, vt], o = R(), s = a(o, V);
  d(s, i, s), d(s, t.domain, s);
  const r = R(), l = R(), h = R();
  d(o, t.domain, r), d(o, t.scheme, l), d(o, t.slashscheme, h), d(r, i, s), d(r, t.domain, r);
  const c = a(r, H);
  a(s, H, c), a(l, H, c), a(h, H, c);
  const f = a(s, O);
  d(f, i, s), d(f, t.domain, s);
  const u = R();
  d(c, t.domain, u), d(u, t.domain, u);
  const g = a(u, O);
  d(g, t.domain, u);
  const p = R(ke);
  d(g, t.tld, p), d(g, t.utld, p), a(c, Y, p);
  const b = a(u, S);
  a(b, S, b), d(b, t.domain, u), d(p, t.domain, u), a(p, O, g), a(p, S, b);
  const A = a(p, M);
  d(A, t.numeric, ke);
  const x = a(r, S), m = a(r, O);
  a(x, S, x), d(x, t.domain, r), d(m, i, s), d(m, t.domain, r);
  const L = R(nt);
  d(m, t.tld, L), d(m, t.utld, L), d(L, t.domain, r), d(L, i, s), a(L, O, m), a(L, S, x), a(L, H, c);
  const Pe = a(L, M), ue = R(nt);
  d(Pe, t.numeric, ue);
  const C = R(nt), F = R();
  d(C, n, C), d(C, e, F), d(F, n, C), d(F, e, F), a(L, v, C), a(ue, v, C);
  const It = a(l, M), we = a(h, M), Ie = a(we, v), Ht = a(Ie, v);
  d(l, t.domain, r), a(l, O, m), a(l, S, x), d(h, t.domain, r), a(h, O, m), a(h, S, x), d(It, t.domain, C), a(It, v, C), a(It, J, C), d(Ht, t.domain, C), d(Ht, n, C), a(Ht, v, C);
  const de = [
    [Q, $],
    // {}
    [st, rt],
    // []
    [at, lt],
    // ()
    [ct, ut],
    // <>
    [dt, ht],
    // （）
    [ft, mt],
    // 「」
    [gt, pt],
    // 『』
    [Et, kt]
    // ＜＞
  ];
  for (let Mt = 0; Mt < de.length; Mt++) {
    const [he, Dt] = de[Mt], Z = a(C, he);
    a(F, he, Z), a(Z, Dt, C);
    const j = R(nt);
    d(Z, n, j);
    const W = R();
    d(Z, e), d(j, n, j), d(j, e, W), d(W, n, j), d(W, e, W), a(j, Dt, C), a(W, Dt, C);
  }
  return a(o, Y, L), a(o, ne, ln), {
    start: o,
    tokens: Se
  };
}
function un(t, n, e) {
  let i = e.length, o = 0, s = [], r = [];
  for (; o < i; ) {
    let l = t, h = null, c = null, f = 0, u = null, g = -1;
    for (; o < i && !(h = l.go(e[o].t)); )
      r.push(e[o++]);
    for (; o < i && (c = h || l.go(e[o].t)); )
      h = null, l = c, l.accepts() ? (g = 0, u = l) : g >= 0 && g++, o++, f++;
    if (g < 0)
      o -= f, o < i && (r.push(e[o]), o++);
    else {
      r.length > 0 && (s.push(Kt(Ae, n, r)), r = []), o -= g, f -= g;
      const p = u.t, b = e.slice(o - f, o);
      s.push(Kt(p, n, b));
    }
  }
  return r.length > 0 && s.push(Kt(Ae, n, r)), s;
}
function Kt(t, n, e) {
  const i = e[0].s, o = e[e.length - 1].e, s = n.slice(i, o);
  return new t(s, e);
}
const dn = typeof console < "u" && console && console.warn || (() => {
}), hn = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", E = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function fn() {
  return y.groups = {}, E.scanner = null, E.parser = null, E.tokenQueue = [], E.pluginQueue = [], E.customSchemes = [], E.initialized = !1, E;
}
function Le(t, n = !1) {
  if (E.initialized && dn(`linkifyjs: already initialized - will not register custom scheme "${t}" ${hn}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  E.customSchemes.push([t, n]);
}
function mn() {
  E.scanner = rn(E.customSchemes);
  for (let t = 0; t < E.tokenQueue.length; t++)
    E.tokenQueue[t][1]({
      scanner: E.scanner
    });
  E.parser = cn(E.scanner.tokens);
  for (let t = 0; t < E.pluginQueue.length; t++)
    E.pluginQueue[t][1]({
      scanner: E.scanner,
      parser: E.parser
    });
  return E.initialized = !0, E;
}
function ce(t) {
  return E.initialized || mn(), un(E.parser.start, t, Oe(E.scanner.start, t));
}
ce.scan = Oe;
function Ne(t, n = null, e = null) {
  if (n && typeof n == "object") {
    if (e)
      throw Error(`linkifyjs: Invalid link type ${n}; must be a string`);
    e = n, n = null;
  }
  const i = new le(e), o = ce(t), s = [];
  for (let r = 0; r < o.length; r++) {
    const l = o[r];
    l.isLink && (!n || l.t === n) && i.check(l) && s.push(l.toFormattedObject(i));
  }
  return s;
}
function gn(t) {
  return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1;
}
function pn(t) {
  return new Pt({
    key: new te("autolink"),
    appendTransaction: (n, e, i) => {
      const o = n.some((c) => c.docChanged) && !e.doc.eq(i.doc), s = n.some((c) => c.getMeta("preventAutolink"));
      if (!o || s)
        return;
      const { tr: r } = i, l = Ue(e.doc, [...n]);
      if (je(l).forEach(({ newRange: c }) => {
        const f = Be(i.doc, c, (p) => p.isTextblock);
        let u, g;
        if (f.length > 1 ? (u = f[0], g = i.doc.textBetween(u.pos, u.pos + u.node.nodeSize, void 0, " ")) : f.length && i.doc.textBetween(c.from, c.to, " ", " ").endsWith(" ") && (u = f[0], g = i.doc.textBetween(u.pos, c.to, void 0, " ")), u && g) {
          const p = g.split(" ").filter((m) => m !== "");
          if (p.length <= 0)
            return !1;
          const b = p[p.length - 1], A = u.pos + g.lastIndexOf(b);
          if (!b)
            return !1;
          const x = ce(b).map((m) => m.toObject(t.defaultProtocol));
          if (!gn(x))
            return !1;
          x.filter((m) => m.isLink).map((m) => ({
            ...m,
            from: A + m.start + 1,
            to: A + m.end + 1
          })).filter((m) => i.schema.marks.code ? !i.doc.rangeHasMark(m.from, m.to, i.schema.marks.code) : !0).filter((m) => t.validate(m.value)).filter((m) => t.shouldAutoLink(m.value)).forEach((m) => {
            ze(m.from, m.to, i.doc).some((L) => L.mark.type === t.type) || r.addMark(m.from, m.to, t.type.create({
              href: m.href
            }));
          });
        }
      }), !!r.steps.length)
        return r;
    }
  });
}
function En(t) {
  return new Pt({
    key: new te("handleClickLink"),
    props: {
      handleClick: (n, e, i) => {
        var o, s;
        if (i.button !== 0 || !n.editable)
          return !1;
        let r = i.target;
        const l = [];
        for (; r.nodeName !== "DIV"; )
          l.push(r), r = r.parentNode;
        if (!l.find((g) => g.nodeName === "A"))
          return !1;
        const h = Fe(n.state, t.type.name), c = i.target, f = (o = c == null ? void 0 : c.href) !== null && o !== void 0 ? o : h.href, u = (s = c == null ? void 0 : c.target) !== null && s !== void 0 ? s : h.target;
        return c && f ? (window.open(f, u), !0) : !1;
      }
    }
  });
}
function kn(t) {
  return new Pt({
    key: new te("handlePasteLink"),
    props: {
      handlePaste: (n, e, i) => {
        const { state: o } = n, { selection: s } = o, { empty: r } = s;
        if (r)
          return !1;
        let l = "";
        i.content.forEach((c) => {
          l += c.textContent;
        });
        const h = Ne(l, { defaultProtocol: t.defaultProtocol }).find((c) => c.isLink && c.value === l);
        return !l || !h ? !1 : t.editor.commands.setMark(t.type, {
          href: h.href
        });
      }
    }
  });
}
const An = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function D(t, n) {
  const e = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp"
  ];
  return n && n.forEach((i) => {
    const o = typeof i == "string" ? i : i.scheme;
    o && e.push(o);
  }), !t || t.replace(An, "").match(new RegExp(
    // eslint-disable-next-line no-useless-escape
    `^(?:(?:${e.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
    "i"
  ));
}
const Ln = Me.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((t) => {
      if (typeof t == "string") {
        Le(t);
        return;
      }
      Le(t.scheme, t.optionalSlashes);
    });
  },
  onDestroy() {
    fn();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (t, n) => !!D(t, n.protocols),
      validate: (t) => !!t,
      shouldAutoLink: (t) => !!t
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(t) {
          return t.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (t) => {
          const n = t.getAttribute("href");
          return !n || !this.options.isAllowedUri(n, {
            defaultValidate: (e) => !!D(e, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return this.options.isAllowedUri(t.href, {
      defaultValidate: (n) => !!D(n, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", _t(this.options.HTMLAttributes, t), 0] : [
      "a",
      _t(this.options.HTMLAttributes, { ...t, href: "" }),
      0
    ];
  },
  addCommands() {
    return {
      setLink: (t) => ({ chain: n }) => {
        const { href: e } = t;
        return this.options.isAllowedUri(e, {
          defaultValidate: (i) => !!D(i, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? n().setMark(this.name, t).setMeta("preventAutolink", !0).run() : !1;
      },
      toggleLink: (t) => ({ chain: n }) => {
        const { href: e } = t;
        return this.options.isAllowedUri(e, {
          defaultValidate: (i) => !!D(i, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? n().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run() : !1;
      },
      unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      De({
        find: (t) => {
          const n = [];
          if (t) {
            const { protocols: e, defaultProtocol: i } = this.options, o = Ne(t).filter((s) => s.isLink && this.options.isAllowedUri(s.value, {
              defaultValidate: (r) => !!D(r, e),
              protocols: e,
              defaultProtocol: i
            }));
            o.length && o.forEach((s) => n.push({
              text: s.value,
              data: {
                href: s.href
              },
              index: s.start
            }));
          }
          return n;
        },
        type: this.type,
        getAttributes: (t) => {
          var n;
          return {
            href: (n = t.data) === null || n === void 0 ? void 0 : n.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = [], { protocols: n, defaultProtocol: e } = this.options;
    return this.options.autolink && t.push(pn({
      type: this.type,
      defaultProtocol: this.options.defaultProtocol,
      validate: (i) => this.options.isAllowedUri(i, {
        defaultValidate: (o) => !!D(o, n),
        protocols: n,
        defaultProtocol: e
      }),
      shouldAutoLink: this.options.shouldAutoLink
    })), this.options.openOnClick === !0 && t.push(En({
      type: this.type
    })), this.options.linkOnPaste && t.push(kn({
      editor: this.editor,
      defaultProtocol: this.options.defaultProtocol,
      type: this.type
    })), t;
  }
});
function Tn(t) {
  const [n, e] = Gt(!1);
  function i(o, s, r) {
    t.action && (t.action({ link: o, text: s, openInNewTab: r }), e(!1));
  }
  return /* @__PURE__ */ it(qe, { modal: !0, open: n, onOpenChange: e, children: [
    /* @__PURE__ */ T(Je, { disabled: t == null ? void 0 : t.disabled, asChild: !0, children: /* @__PURE__ */ T(
      Ge,
      {
        tooltip: t == null ? void 0 : t.tooltip,
        isActive: t == null ? void 0 : t.isActive,
        disabled: t == null ? void 0 : t.disabled,
        children: /* @__PURE__ */ T(Te, { name: t == null ? void 0 : t.icon })
      }
    ) }),
    /* @__PURE__ */ T(Ve, { hideWhenDetached: !0, className: "richtext-w-full", align: "start", side: "bottom", children: /* @__PURE__ */ T(Cn, { editor: t.editor, onSetLink: i }) })
  ] });
}
const xn = /* @__PURE__ */ Ln.extend({
  inclusive: !1,
  parseHTML() {
    return [
      {
        tag: 'a[href]:not([data-type="button"]):not([href *= "javascript:" i])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "a",
      _t(this.options.HTMLAttributes, t, {
        class: "link"
      }),
      0
    ];
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      openOnClick: !0,
      button: ({ editor: n, t: e }) => ({
        component: Tn,
        componentProps: {
          editor: n,
          action: (i) => {
            const { link: o, text: s, openInNewTab: r } = i, { state: l } = n, { from: h } = l.selection, c = s.length, f = h + c;
            n.chain().extendMarkRange("link").insertContent({
              type: "text",
              text: s,
              marks: [
                {
                  type: "link",
                  attrs: {
                    href: o,
                    target: r ? "_blank" : ""
                  }
                }
              ]
            }).setLink({ href: o }).setTextSelection({ from: h, to: f }).focus().run();
          },
          id: "linkk",
          isActive: () => n.isActive("link") || !1,
          disabled: !n.can().setLink({ href: "" }),
          icon: "Link",
          tooltip: e("editor.link.tooltip")
        }
      })
    };
  },
  addProseMirrorPlugins() {
    return [
      new Pt({
        props: {
          handleClick: (t, n) => {
            const { schema: e, doc: i, tr: o } = t.state, s = We(i.resolve(n), e.marks.link);
            if (!s)
              return !1;
            const r = i.resolve(s.from), l = i.resolve(s.to), h = o.setSelection(
              new Ke(r, l)
            );
            t.dispatch(h);
          }
        }
      })
    ];
  }
});
function Cn(t) {
  const { t: n } = _e(), [e, i] = Gt({
    text: "",
    link: ""
  }), [o, s] = Gt(!1);
  He(() => {
    const l = () => {
      var h, c, f;
      if ((h = t.editor) != null && h.isActive("link")) {
        const { href: u, target: g } = t.editor.getAttributes("link"), { from: p, to: b } = t.editor.state.selection, A = t.editor.state.doc.textBetween(p, b, " ");
        i({ link: u || "", text: A }), s(g === "_blank");
      } else {
        const u = (c = t.editor.extensionManager.extensions.find(
          (g) => g.name === xn.name
        )) == null ? void 0 : c.options;
        s(((f = u == null ? void 0 : u.HTMLAttributes) == null ? void 0 : f.target) === "_blank");
      }
    };
    return l(), t.editor.on("selectionUpdate", l), () => {
      t.editor.off("selectionUpdate", l);
    };
  }, [t.editor]);
  function r(l) {
    l.preventDefault(), l.stopPropagation(), t == null || t.onSetLink(e.link, e.text, o), i({ text: "", link: "" });
  }
  return /* @__PURE__ */ T("div", { className: "border-neutral-200 richtext-rounded-lg !richtext-border richtext-bg-white richtext-p-2 richtext-shadow-sm dark:richtext-border-neutral-800 dark:richtext-bg-black", children: /* @__PURE__ */ it("div", { className: "richtext-flex richtext-flex-col richtext-gap-2", children: [
    /* @__PURE__ */ T(Ut, { className: "mb-[6px]", children: n("editor.link.dialog.text") }),
    /* @__PURE__ */ T("div", { className: "richtext-mb-[10px] richtext-flex richtext-w-full richtext-max-w-sm richtext-items-center richtext-gap-1.5", children: /* @__PURE__ */ T("div", { className: "richtext-relative richtext-w-full richtext-max-w-sm richtext-items-center", children: /* @__PURE__ */ T(
      fe,
      {
        className: "richtext-w-80",
        onChange: (l) => i({ ...e, text: l.target.value }),
        placeholder: "Text",
        required: !0,
        type: "text",
        value: e.text
      }
    ) }) }),
    /* @__PURE__ */ T(Ut, { className: "mb-[6px]", children: n("editor.link.dialog.link") }),
    /* @__PURE__ */ T("div", { className: "richtext-flex richtext-w-full richtext-max-w-sm richtext-items-center richtext-gap-1.5", children: /* @__PURE__ */ it("div", { className: "richtext-relative richtext-w-full richtext-max-w-sm richtext-items-center", children: [
      /* @__PURE__ */ T(
        fe,
        {
          className: "richtext-pl-10",
          onChange: (l) => i({ ...e, link: l.target.value }),
          required: !0,
          type: "url",
          value: e.link
        }
      ),
      /* @__PURE__ */ T("span", { className: "richtext-absolute richtext-inset-y-0 richtext-start-0 richtext-flex richtext-items-center richtext-justify-center richtext-px-2", children: /* @__PURE__ */ T(
        Te,
        {
          className: "richtext-size-5 richtext-text-muted-foreground",
          name: "Link"
        }
      ) })
    ] }) }),
    /* @__PURE__ */ it("div", { className: "richtext-flex richtext-items-center richtext-space-x-2", children: [
      /* @__PURE__ */ T(Ut, { children: n("editor.link.dialog.openInNewTab") }),
      /* @__PURE__ */ T(
        Qe,
        {
          checked: o,
          onCheckedChange: (l) => {
            s(l);
          }
        }
      )
    ] }),
    /* @__PURE__ */ T(
      $e,
      {
        className: "richtext-mt-2 richtext-self-end",
        onClick: r,
        type: "button",
        children: n("editor.link.dialog.button.apply")
      }
    )
  ] }) });
}
export {
  Cn as L,
  xn as a
};
